@using Algorithms
@using System.Reflection
@typeparam TInput
@typeparam TState where TState : StateBase, new()
@typeparam TSolutions

<PageTitle>@title</PageTitle>

<h1>@title</h1>

<input type="range" id="delayRange" @bind=delay min="0" max="1000">
<div class="my-4">
    <span class="p-2 rounded bg-light">@(delay == 0 ? "Fastest" : delay == 1000 ? "Animation Stopped" : $"Run a step every {delay} ms")</span>
</div>
    @if (Input is not null)
{
    @if (isProcessing)
    {
        <div>
            <button class="btn btn-primary" @onclick="(e) => { cts?.Cancel();}">Cancel</button>
        </div>
    }
    else
    {
        <div>
            @foreach (var method in methods)
            {
                <button class="btn btn-primary" @onclick="(e) => StartSolving(method.Method)">Solve @method.Name</button>
            }
        </div>
    }
}
@if (state is not null)
{
    <p class="p-2" role="status">Solution: @state.Message</p>
    if (ChildContent is not null)
    {
        @ChildContent((delay, iteration, state))
    }
}

@code {
    [Parameter]
    public TInput? Input { get; set; }
    [Parameter]
    public RenderFragment<(int Delay, int Iteration, TState State)>? ChildContent { get; set; }

    private string title = PuzzleHelper.GetPuzzleTitle(typeof(TSolutions));
    private List<(string Name, Func<TInput, IEnumerable<Func<TState>>> Method)> methods = PuzzleHelper.GetPuzzleMethods<TInput, TState>(typeof(TSolutions));
    private TState? state;
    private int delay = 500;
    private bool isProcessing;
    private CancellationTokenSource? cts;
    private int iteration;

    private async Task StartSolving(Func<TInput, IEnumerable<Func<TState>>> part)
    {
        cts = new CancellationTokenSource();
        var token = cts.Token;
        await Solve(part(Input!), token);
        StateHasChanged();
    }

    private async Task Solve(IEnumerable<Func<TState>> steps, CancellationToken token)
    {
        isProcessing = true;
        iteration = 0;
        Func<TState>? s = null;
        state = new TState
        {
            Message = "Running"
        };
        StateHasChanged();
        await Task.Delay(1);
        foreach (var step in steps)
        {
            s = step;
            iteration++;
            if (delay > 0)
            {
                state = step.Invoke();
                StateHasChanged();
                await Task.Delay(delay);
                if (token.IsCancellationRequested)
                {
                    state.Message = "Processing Cancelled";
                    break;
                }
            }
        }
        state = s!.Invoke();
        isProcessing = false;
    }
}
