@using Algorithms
@using System.Reflection
@typeparam TInput

<p>@title</p>

    @if (Input is not null)
{
    @if (isProcessing)
    {
        <div>
            <button class="btn btn-primary" @onclick="(e) => { cts?.Cancel();}">
             <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
                Iteration @iteration ... Cancel
            </button>
        </div>
    }
    else
    {
        <div>
            @if (Solution?.Solution is not null)
            {
                <span class="border rounded p-2">@($"Solution found is {Solution.Solution}")</span>
            }
            <button class="btn btn-primary" @onclick="(e) => StartSolving()">
                @(Solution?.Solution is not null ? "Restart" : "Start")
            </button>
        </div>
    }
}
@if (Solution is not null && ChildContent is not null)
{
    @ChildContent(iteration)
}

@code {
    [Parameter]
    public int Delay { get; set; }
    [Parameter]
    public TInput? Input { get; set; }
    [Parameter]
    public ISolutionFinder<TInput>? Solution { get; set; }
    [Parameter]
    public RenderFragment<int>? ChildContent { get; set; }

    private string title => Solution is null ? string.Empty : PuzzleHelper.GetPuzzleTitle(Solution.GetType());
    private bool isProcessing;
    private CancellationTokenSource? cts;
    private int iteration;

    private async Task StartSolving()
    {
        cts = new CancellationTokenSource();
        var token = cts.Token;
        await Solve(token);
        StateHasChanged();
    }

    private async Task Solve(CancellationToken token)
    {
        isProcessing = true;
        iteration = 0;
        Solution!.Start(Input!);
        StateHasChanged();
        await Task.Delay(1);
        while (Solution.Solution is null)
        {
            Solution.Update();
            iteration++;
            if (Delay > 0)
            {
                StateHasChanged();
                await Task.Delay(Delay);
                if (token.IsCancellationRequested)
                    break;
            }
        }
        isProcessing = false;
    }
}
